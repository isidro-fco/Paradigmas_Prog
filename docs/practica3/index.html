<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Practica3 | Paradigmas de la Programación</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Práctica 3: Haskell
Isidro Francisco Pérez Paz - 377806

Instalación del entorno de Haskell
Descarga entorno
Para poder utilizar Haskell:


Dirigete a la pagina de Haskell y ve a la pestaña de Descargas
Dentro te va aparecer esto:



Pulsa en el recuadro morado &ldquo;GHCup&rdquo;
Ya dentro copia el comando que aparece aqui:



Dirigete a PowerShell pegalo, ejecutalo y instala todo
Nota: no lo ejecutes como administrador.




Funcionamiento de la aplicación TODO escrita en Haskell

Inicialización del proyecto

Se crea un nuevo proyecto usando Stack como plantilla.
Se establece el archivo package.yaml o .cabal, se configuran dependencias mínimas y se pueden añadir otras como dotenv, open-browser.
Se compila/testea con stack build, stack test, stack run.


Ejecución de la aplicación

Al ejecutar stack run, se muestra un menú con comandos disponibles:

Luego se invoca la función prompt [] con la lista de todos inicialmente vacía.


Bucle interactivo

Dentro de prompt todos, se imprime un mensaje para el usuario pidiendo un comando.
Se lee la línea de entrada del usuario.
Si el comando comienza con &lsquo;e&rsquo; (editar), se primero pide “What is the new todo for that?” y se lee la nueva descripción, luego llama editTodo.
En otro caso, se llama a interpret command todos que analiza el comando y actúa según el prefijo.



Interpretación de comandos
Dependiendo del comando dado:

(&rsquo;&#43;&rsquo;: &rsquo; &rsquo; : todo): agrega un nuevo todo al frente de la lista: construye la nueva lista todo : todos, y vuelve a prompt con los nuevos todos.
(&rsquo;-&rsquo;: &rsquo; &rsquo; : num): lee num como índice, llama deleteOne (read num) todos. Si devuelve Nothing, imprime “No TODO entry matches the given number” y vuelve al prompt con la lista sin cambios; si Just todos&#39;, entonces pasa todos&#39; al prompt.
(&rsquo;s&rsquo;: &rsquo; &rsquo; : num): muestra el elemento número num si existe, usando showOne. Si no, muestra mensaje de error. Luego vuelve al prompt con la misma lista.
&ldquo;l&rdquo;: lista todos los elementos actuales: calcula length todos, imprime cuántos en total; hacen mapM_ putTodo (zip [0..] todos) (imprime índice y el todo) luego vuelve al prompt.
&ldquo;r&rdquo;: muestra la lista invertida: calcula reversedTodos = reverseTodos todos, luego similar a l, imprime la invertida, luego vuelve al prompt con la lista original aún intacta (importante: no la sustituye).
&ldquo;c&rdquo;: limpia la lista: imprime “Clear todo list.” y llama prompt [] (lista vacía).
&ldquo;q&rdquo;: termina el bucle: interpret &quot;q&quot; todos = return ().
Cualquier otro comando — imprime Invalid command: \ `` y vuelve al prompt con la lista sin cambios.


Funciones auxiliares

deleteOne :: Int -&gt; [a] -&gt; Maybe [a]: elimina el elemento en índice dado, si existe; de lo contrario Nothing.
showOne :: Int -&gt; [a] -&gt; Maybe a: devuelve el elemento en índice dado, si válido; de lo contrario Nothing.
editIndex :: Int -&gt; a -&gt; [a] -&gt; [a]: cambia el elemento en índice i a x, construyendo nueva lista (inmutabilidad).
editTodo :: String -&gt; [String] -&gt; String -&gt; IO (): se encarga del flujo cuando se edita: parsea el índice desde comando (&#39;e&#39;: &#39; &#39; : num), llama editOne, imprime “Old todo is …”, “New todo is …”, luego imprime el nuevo estado (número de elementos y lista), y llama prompt newTodos.
reverseTodos :: [a] -&gt; [a]: invierte la lista implementando recursivamente go xs [].




Estructura del código

app/Main.hs: donde está la función main, imprime los comandos y llama prompt [].
src/Lib.hs: contiene la lógica del prompt, la interpretación de comandos, y las funciones auxiliares como deleteOne, showOne, editIndex, etc.
test/Spec.hs: contiene al menos una prueba: se explica en el artículo que prueban editIndex, por ejemplo.
package.yaml / stack.yaml: configuración del proyecto con dependencias. El tutorial menciona añadir dotenv y open-browser aunque para la funcionalidad básica del TODO no son estrictamente necesarias.
">
    <meta name="generator" content="Hugo 0.149.1">
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.2438bcafd7af9675c426d1a4afcd16cfff18e4e10f401071e45b5ccd3be40a0d.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://example.org/practica3/">
    

    <meta property="og:url" content="http://example.org/practica3/">
  <meta property="og:site_name" content="Paradigmas de la Programación">
  <meta property="og:title" content="Practica3">
  <meta property="og:description" content="Práctica 3: Haskell Isidro Francisco Pérez Paz - 377806 Instalación del entorno de Haskell Descarga entorno Para poder utilizar Haskell:
Dirigete a la pagina de Haskell y ve a la pestaña de Descargas Dentro te va aparecer esto: Pulsa en el recuadro morado “GHCup” Ya dentro copia el comando que aparece aqui: Dirigete a PowerShell pegalo, ejecutalo y instala todo Nota: no lo ejecutes como administrador. Funcionamiento de la aplicación TODO escrita en Haskell Inicialización del proyecto Se crea un nuevo proyecto usando Stack como plantilla. Se establece el archivo package.yaml o .cabal, se configuran dependencias mínimas y se pueden añadir otras como dotenv, open-browser. Se compila/testea con stack build, stack test, stack run. Ejecución de la aplicación Al ejecutar stack run, se muestra un menú con comandos disponibles: Luego se invoca la función prompt [] con la lista de todos inicialmente vacía. Bucle interactivo Dentro de prompt todos, se imprime un mensaje para el usuario pidiendo un comando. Se lee la línea de entrada del usuario. Si el comando comienza con ‘e’ (editar), se primero pide “What is the new todo for that?” y se lee la nueva descripción, luego llama editTodo. En otro caso, se llama a interpret command todos que analiza el comando y actúa según el prefijo. Interpretación de comandos Dependiendo del comando dado: (’&#43;’: ’ ’ : todo): agrega un nuevo todo al frente de la lista: construye la nueva lista todo : todos, y vuelve a prompt con los nuevos todos. (’-’: ’ ’ : num): lee num como índice, llama deleteOne (read num) todos. Si devuelve Nothing, imprime “No TODO entry matches the given number” y vuelve al prompt con la lista sin cambios; si Just todos&#39;, entonces pasa todos&#39; al prompt. (’s’: ’ ’ : num): muestra el elemento número num si existe, usando showOne. Si no, muestra mensaje de error. Luego vuelve al prompt con la misma lista. “l”: lista todos los elementos actuales: calcula length todos, imprime cuántos en total; hacen mapM_ putTodo (zip [0..] todos) (imprime índice y el todo) luego vuelve al prompt. “r”: muestra la lista invertida: calcula reversedTodos = reverseTodos todos, luego similar a l, imprime la invertida, luego vuelve al prompt con la lista original aún intacta (importante: no la sustituye). “c”: limpia la lista: imprime “Clear todo list.” y llama prompt [] (lista vacía). “q”: termina el bucle: interpret &#34;q&#34; todos = return (). Cualquier otro comando — imprime Invalid command: \ `` y vuelve al prompt con la lista sin cambios. Funciones auxiliares deleteOne :: Int -&gt; [a] -&gt; Maybe [a]: elimina el elemento en índice dado, si existe; de lo contrario Nothing. showOne :: Int -&gt; [a] -&gt; Maybe a: devuelve el elemento en índice dado, si válido; de lo contrario Nothing. editIndex :: Int -&gt; a -&gt; [a] -&gt; [a]: cambia el elemento en índice i a x, construyendo nueva lista (inmutabilidad). editTodo :: String -&gt; [String] -&gt; String -&gt; IO (): se encarga del flujo cuando se edita: parsea el índice desde comando (&#39;e&#39;: &#39; &#39; : num), llama editOne, imprime “Old todo is …”, “New todo is …”, luego imprime el nuevo estado (número de elementos y lista), y llama prompt newTodos. reverseTodos :: [a] -&gt; [a]: invierte la lista implementando recursivamente go xs []. Estructura del código app/Main.hs: donde está la función main, imprime los comandos y llama prompt []. src/Lib.hs: contiene la lógica del prompt, la interpretación de comandos, y las funciones auxiliares como deleteOne, showOne, editIndex, etc. test/Spec.hs: contiene al menos una prueba: se explica en el artículo que prueban editIndex, por ejemplo. package.yaml / stack.yaml: configuración del proyecto con dependencias. El tutorial menciona añadir dotenv y open-browser aunque para la funcionalidad básica del TODO no son estrictamente necesarias.">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-11-07T17:18:59-08:00">
    <meta property="article:modified_time" content="2025-11-07T17:18:59-08:00">

  <meta itemprop="name" content="Practica3">
  <meta itemprop="description" content="Práctica 3: Haskell Isidro Francisco Pérez Paz - 377806 Instalación del entorno de Haskell Descarga entorno Para poder utilizar Haskell:
Dirigete a la pagina de Haskell y ve a la pestaña de Descargas Dentro te va aparecer esto: Pulsa en el recuadro morado “GHCup” Ya dentro copia el comando que aparece aqui: Dirigete a PowerShell pegalo, ejecutalo y instala todo Nota: no lo ejecutes como administrador. Funcionamiento de la aplicación TODO escrita en Haskell Inicialización del proyecto Se crea un nuevo proyecto usando Stack como plantilla. Se establece el archivo package.yaml o .cabal, se configuran dependencias mínimas y se pueden añadir otras como dotenv, open-browser. Se compila/testea con stack build, stack test, stack run. Ejecución de la aplicación Al ejecutar stack run, se muestra un menú con comandos disponibles: Luego se invoca la función prompt [] con la lista de todos inicialmente vacía. Bucle interactivo Dentro de prompt todos, se imprime un mensaje para el usuario pidiendo un comando. Se lee la línea de entrada del usuario. Si el comando comienza con ‘e’ (editar), se primero pide “What is the new todo for that?” y se lee la nueva descripción, luego llama editTodo. En otro caso, se llama a interpret command todos que analiza el comando y actúa según el prefijo. Interpretación de comandos Dependiendo del comando dado: (’&#43;’: ’ ’ : todo): agrega un nuevo todo al frente de la lista: construye la nueva lista todo : todos, y vuelve a prompt con los nuevos todos. (’-’: ’ ’ : num): lee num como índice, llama deleteOne (read num) todos. Si devuelve Nothing, imprime “No TODO entry matches the given number” y vuelve al prompt con la lista sin cambios; si Just todos&#39;, entonces pasa todos&#39; al prompt. (’s’: ’ ’ : num): muestra el elemento número num si existe, usando showOne. Si no, muestra mensaje de error. Luego vuelve al prompt con la misma lista. “l”: lista todos los elementos actuales: calcula length todos, imprime cuántos en total; hacen mapM_ putTodo (zip [0..] todos) (imprime índice y el todo) luego vuelve al prompt. “r”: muestra la lista invertida: calcula reversedTodos = reverseTodos todos, luego similar a l, imprime la invertida, luego vuelve al prompt con la lista original aún intacta (importante: no la sustituye). “c”: limpia la lista: imprime “Clear todo list.” y llama prompt [] (lista vacía). “q”: termina el bucle: interpret &#34;q&#34; todos = return (). Cualquier otro comando — imprime Invalid command: \ `` y vuelve al prompt con la lista sin cambios. Funciones auxiliares deleteOne :: Int -&gt; [a] -&gt; Maybe [a]: elimina el elemento en índice dado, si existe; de lo contrario Nothing. showOne :: Int -&gt; [a] -&gt; Maybe a: devuelve el elemento en índice dado, si válido; de lo contrario Nothing. editIndex :: Int -&gt; a -&gt; [a] -&gt; [a]: cambia el elemento en índice i a x, construyendo nueva lista (inmutabilidad). editTodo :: String -&gt; [String] -&gt; String -&gt; IO (): se encarga del flujo cuando se edita: parsea el índice desde comando (&#39;e&#39;: &#39; &#39; : num), llama editOne, imprime “Old todo is …”, “New todo is …”, luego imprime el nuevo estado (número de elementos y lista), y llama prompt newTodos. reverseTodos :: [a] -&gt; [a]: invierte la lista implementando recursivamente go xs []. Estructura del código app/Main.hs: donde está la función main, imprime los comandos y llama prompt []. src/Lib.hs: contiene la lógica del prompt, la interpretación de comandos, y las funciones auxiliares como deleteOne, showOne, editIndex, etc. test/Spec.hs: contiene al menos una prueba: se explica en el artículo que prueban editIndex, por ejemplo. package.yaml / stack.yaml: configuración del proyecto con dependencias. El tutorial menciona añadir dotenv y open-browser aunque para la funcionalidad básica del TODO no son estrictamente necesarias.">
  <meta itemprop="datePublished" content="2025-11-07T17:18:59-08:00">
  <meta itemprop="dateModified" content="2025-11-07T17:18:59-08:00">
  <meta itemprop="wordCount" content="623">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Practica3">
  <meta name="twitter:description" content="Práctica 3: Haskell Isidro Francisco Pérez Paz - 377806 Instalación del entorno de Haskell Descarga entorno Para poder utilizar Haskell:
Dirigete a la pagina de Haskell y ve a la pestaña de Descargas Dentro te va aparecer esto: Pulsa en el recuadro morado “GHCup” Ya dentro copia el comando que aparece aqui: Dirigete a PowerShell pegalo, ejecutalo y instala todo Nota: no lo ejecutes como administrador. Funcionamiento de la aplicación TODO escrita en Haskell Inicialización del proyecto Se crea un nuevo proyecto usando Stack como plantilla. Se establece el archivo package.yaml o .cabal, se configuran dependencias mínimas y se pueden añadir otras como dotenv, open-browser. Se compila/testea con stack build, stack test, stack run. Ejecución de la aplicación Al ejecutar stack run, se muestra un menú con comandos disponibles: Luego se invoca la función prompt [] con la lista de todos inicialmente vacía. Bucle interactivo Dentro de prompt todos, se imprime un mensaje para el usuario pidiendo un comando. Se lee la línea de entrada del usuario. Si el comando comienza con ‘e’ (editar), se primero pide “What is the new todo for that?” y se lee la nueva descripción, luego llama editTodo. En otro caso, se llama a interpret command todos que analiza el comando y actúa según el prefijo. Interpretación de comandos Dependiendo del comando dado: (’&#43;’: ’ ’ : todo): agrega un nuevo todo al frente de la lista: construye la nueva lista todo : todos, y vuelve a prompt con los nuevos todos. (’-’: ’ ’ : num): lee num como índice, llama deleteOne (read num) todos. Si devuelve Nothing, imprime “No TODO entry matches the given number” y vuelve al prompt con la lista sin cambios; si Just todos&#39;, entonces pasa todos&#39; al prompt. (’s’: ’ ’ : num): muestra el elemento número num si existe, usando showOne. Si no, muestra mensaje de error. Luego vuelve al prompt con la misma lista. “l”: lista todos los elementos actuales: calcula length todos, imprime cuántos en total; hacen mapM_ putTodo (zip [0..] todos) (imprime índice y el todo) luego vuelve al prompt. “r”: muestra la lista invertida: calcula reversedTodos = reverseTodos todos, luego similar a l, imprime la invertida, luego vuelve al prompt con la lista original aún intacta (importante: no la sustituye). “c”: limpia la lista: imprime “Clear todo list.” y llama prompt [] (lista vacía). “q”: termina el bucle: interpret &#34;q&#34; todos = return (). Cualquier otro comando — imprime Invalid command: \ `` y vuelve al prompt con la lista sin cambios. Funciones auxiliares deleteOne :: Int -&gt; [a] -&gt; Maybe [a]: elimina el elemento en índice dado, si existe; de lo contrario Nothing. showOne :: Int -&gt; [a] -&gt; Maybe a: devuelve el elemento en índice dado, si válido; de lo contrario Nothing. editIndex :: Int -&gt; a -&gt; [a] -&gt; [a]: cambia el elemento en índice i a x, construyendo nueva lista (inmutabilidad). editTodo :: String -&gt; [String] -&gt; String -&gt; IO (): se encarga del flujo cuando se edita: parsea el índice desde comando (&#39;e&#39;: &#39; &#39; : num), llama editOne, imprime “Old todo is …”, “New todo is …”, luego imprime el nuevo estado (número de elementos y lista), y llama prompt newTodos. reverseTodos :: [a] -&gt; [a]: invierte la lista implementando recursivamente go xs []. Estructura del código app/Main.hs: donde está la función main, imprime los comandos y llama prompt []. src/Lib.hs: contiene la lógica del prompt, la interpretación de comandos, y las funciones auxiliares como deleteOne, showOne, editIndex, etc. test/Spec.hs: contiene al menos una prueba: se explica en el artículo que prueban editIndex, por ejemplo. package.yaml / stack.yaml: configuración del proyecto con dependencias. El tutorial menciona añadir dotenv y open-browser aunque para la funcionalidad básica del TODO no son estrictamente necesarias.">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Paradigmas de la Programación
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/contacto/" title="Contacto page">
              Contacto
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/paradigmas_progm/" title="Paradigmas de la Programación page">
              Paradigmas de la Programación
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Paradigmas de la Programación
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Practica3</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-11-07T17:18:59-08:00">November 7, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="práctica-3-haskell"><strong>Práctica 3: Haskell</strong></h1>
<h4 id="isidro-francisco-pérez-paz---377806"><strong>Isidro Francisco Pérez Paz - 377806</strong></h4>
<hr>
<h2 id="instalación-del-entorno-de-haskell"><strong>Instalación del entorno de Haskell</strong></h2>
<h3 id="descarga-entorno"><strong>Descarga entorno</strong></h3>
<p>Para poder utilizar <em>Haskell</em>:</p>
<ol>
<li>
<p><strong>Dirigete a la pagina de <em>Haskell</em> y ve a la pestaña de <a href="https://www.haskell.org/downloads/" title="Haskell/Download">Descargas</a></strong>
Dentro te va aparecer esto:
<img src="img/img1.png" alt=""></p>
</li>
<li>
<p><strong>Pulsa en el recuadro morado &ldquo;<a href="https://www.haskell.org/ghcup/" title="GHCup">GHCup</a>&rdquo;</strong>
Ya dentro copia el comando que aparece aqui:
<img src="img/img2.png" alt=""></p>
</li>
<li>
<p><strong>Dirigete a <em>PowerShell</em> pegalo, ejecutalo y instala todo</strong>
<strong>Nota:</strong> no lo ejecutes como administrador.
<img src="img/img3.png" alt=""></p>
</li>
</ol>
<hr>
<h2 id="funcionamiento-de-la-aplicación-todo-escrita-en-haskell"><strong>Funcionamiento de la aplicación TODO escrita en Haskell</strong></h2>
<ol>
<li><strong>Inicialización del proyecto</strong>
<ul>
<li>Se crea un nuevo proyecto usando Stack como plantilla.</li>
<li>Se establece el archivo <strong>package.yaml</strong> o <strong>.cabal</strong>, se configuran dependencias mínimas y se pueden añadir otras como <strong>dotenv</strong>, <strong>open-browser</strong>.</li>
<li>Se compila/testea con stack build, stack test, stack run.</li>
</ul>
</li>
<li><strong>Ejecución de la aplicación</strong>
<ul>
<li>Al ejecutar <code>stack run</code>, se muestra un menú con comandos disponibles:
<img src="img/img4.png" alt=""></li>
<li>Luego se invoca la función <code>prompt []</code> con la lista de todos inicialmente vacía.</li>
</ul>
</li>
<li><strong>Bucle interactivo</strong>
<ul>
<li>Dentro de <code>prompt todos</code>, se imprime un mensaje para el usuario pidiendo un comando.</li>
<li>Se lee la línea de entrada del usuario.</li>
<li>Si el comando comienza con &lsquo;<strong>e</strong>&rsquo; (editar), se primero pide “What is the new todo for that?” y se lee la nueva descripción, luego llama <code>editTodo</code>.</li>
<li>En otro caso, se llama a <code>interpret command todos</code> que analiza el comando y actúa según el prefijo.
<img src="img/img5.png" alt=""></li>
</ul>
</li>
<li><strong>Interpretación de comandos</strong>
Dependiendo del comando dado:
<ul>
<li><strong>(&rsquo;+&rsquo;: &rsquo; &rsquo; : todo):</strong> agrega un nuevo todo al frente de la lista: construye la nueva lista <code>todo : todos</code>, y vuelve a <code>prompt</code> con los nuevos todos.</li>
<li><strong>(&rsquo;-&rsquo;: &rsquo; &rsquo; : num):</strong> lee <code>num</code> como índice, llama <code>deleteOne (read num) todos</code>. Si devuelve <code>Nothing</code>, imprime “No TODO entry matches the given number” y vuelve al prompt con la lista sin cambios; si <code>Just todos'</code>, entonces pasa <code>todos'</code> al prompt.</li>
<li><strong>(&rsquo;s&rsquo;: &rsquo; &rsquo; : num):</strong> muestra el elemento número <code>num</code> si existe, usando <code>showOne</code>. Si no, muestra mensaje de error. Luego vuelve al prompt con la misma lista.</li>
<li><strong>&ldquo;l&rdquo;:</strong> lista todos los elementos actuales: calcula <code>length todos</code>, imprime cuántos en total; hacen <code>mapM_ putTodo (zip [0..] todos)</code> (imprime índice y el todo) luego vuelve al prompt.</li>
<li><strong>&ldquo;r&rdquo;:</strong> muestra la lista invertida: calcula <code>reversedTodos = reverseTodos todos</code>, luego similar a <code>l</code>, imprime la invertida, luego vuelve al prompt con la lista original aún intacta (importante: no la sustituye).</li>
<li><strong>&ldquo;c&rdquo;:</strong> limpia la lista: imprime “Clear todo list.” y llama <code>prompt []</code> (lista vacía).</li>
<li><strong>&ldquo;q&rdquo;:</strong> termina el bucle: <code>interpret &quot;q&quot; todos = return ()</code>.</li>
<li>Cualquier otro comando — imprime <code>Invalid command: \</code> <!-- raw HTML omitted -->`` y vuelve al prompt con la lista sin cambios.</li>
</ul>
</li>
<li><strong>Funciones auxiliares</strong>
<ul>
<li><strong>deleteOne :: Int -&gt; [a] -&gt; Maybe [a]:</strong> elimina el elemento en índice dado, si existe; de lo contrario <code>Nothing</code>.</li>
<li><strong>showOne :: Int -&gt; [a] -&gt; Maybe a:</strong> devuelve el elemento en índice dado, si válido; de lo contrario <code>Nothing</code>.</li>
<li><strong>editIndex :: Int -&gt; a -&gt; [a] -&gt; [a]:</strong> cambia el elemento en índice <code>i</code> a <code>x</code>, construyendo nueva lista (inmutabilidad).</li>
<li><strong>editTodo :: String -&gt; [String] -&gt; String -&gt; IO ():</strong> se encarga del flujo cuando se edita: parsea el índice desde comando (<code>'e': ' ' : num</code>), llama <code>editOne</code>, imprime “Old todo is …”, “New todo is …”, luego imprime el nuevo estado (número de elementos y lista), y llama <code>prompt newTodos</code>.</li>
<li><strong>reverseTodos :: [a] -&gt; [a]:</strong> invierte la lista implementando recursivamente <code>go xs []</code>.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="estructura-del-código"><strong>Estructura del código</strong></h2>
<ul>
<li><strong>app/Main.hs:</strong> donde está la función <code>main</code>, imprime los comandos y llama <code>prompt []</code>.</li>
<li><strong>src/Lib.hs:</strong> contiene la lógica del prompt, la interpretación de comandos, y las funciones auxiliares como <code>deleteOne</code>, <code>showOne</code>, <code>editIndex</code>, etc.</li>
<li><strong>test/Spec.hs:</strong> contiene al menos una prueba: se explica en el artículo que prueban <code>editIndex</code>, por ejemplo.</li>
<li><strong>package.yaml / stack.yaml:</strong> configuración del proyecto con dependencias. El tutorial menciona añadir <code>dotenv</code> y <code>open-browser</code> aunque para la funcionalidad básica del TODO no son estrictamente necesarias.</li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://example.org/" >
    &copy;  Paradigmas de la Programación 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
